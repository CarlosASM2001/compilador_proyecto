token COMENTARIO
token GLOBAL
token ID
token SEMI
token GLOBAL
	 declaracion global variable
	 declaracion unica
token ID
token SEMI
token FUNCTION
	 declaracion global variable
	 secuencia declaraciones
token ID
token LPAREN
token ID
token RPAREN
token BEGIN
token VAR
token ID
token SEMI
token ID
	 declaracion variable local
	 sentencia unica
token ASSIGN
token ID
token PLUS
	 identificador
token NUM
token SEMI
	 numero entero
	 suma
	 asignacion variable
	 secuencia sentencias sin punto y coma
token COMENTARIO
token IF
token ID
token LE
	 identificador
token NUM
token THEN
	 numero entero
	 operacion menor igual
token ID
token ASSIGN
token NUM
token ELSE
	 numero entero
	 asignacion variable
	 sentencia unica
token ID
token ASSIGN
token ID
token TIMES
	 identificador
token CALL
token ID
token LPAREN
token ID
token MINUS
	 identificador
token NUM
token RPAREN
	 numero entero
	 resta
token END
	 llamada funcion en expresion
	 multiplicacion
	 asignacion variable
	 sentencia unica
token SEMI
	 if-else
	 secuencia sentencias
token RETURN
token ID
token END
	 identificador
	 return con valor
	 secuencia sentencias
token FUNCTION
	 declaracion funcion con parametros
	 secuencia declaraciones
token ID
token LPAREN
token ID
token COMMA
token ID
token RPAREN
	 lista parametros
token BEGIN
token VAR
token ID
token SEMI
token ID
	 declaracion variable local
	 sentencia unica
token ASSIGN
token ID
token PLUS
	 identificador
token ID
token SEMI
	 identificador
	 suma
	 asignacion variable
	 secuencia sentencias sin punto y coma
token ID
token ASSIGN
token ID
token PLUS
	 identificador
token NUM
token SEMI
	 numero entero
	 suma
	 asignacion variable
	 secuencia sentencias
token RETURN
token ID
token END
	 identificador
	 return con valor
	 secuencia sentencias
token BEGIN
	 declaracion funcion con parametros
	 secuencia declaraciones
token VAR
token ID
token SEMI
token VAR
	 declaracion variable local
	 sentencia unica
token ID
token SEMI
token COMENTARIO
token ID
	 declaracion variable local
	 secuencia sentencias sin punto y coma
token ASSIGN
token NUM
token SEMI
	 numero entero
	 asignacion variable
	 secuencia sentencias sin punto y coma
token COMENTARIO
token READ
token ID
token SEMI
	 read variable
	 secuencia sentencias
token ID
token ASSIGN
token CALL
token ID
token LPAREN
token ID
token RPAREN
	 identificador
token SEMI
	 llamada funcion en expresion
	 asignacion variable
	 secuencia sentencias
token WRITE
token ID
token SEMI
	 identificador
	 write expresion
	 secuencia sentencias
token WRITE
token ID
token SEMI
	 identificador
	 write expresion
	 secuencia sentencias
token COMENTARIO
token COMENTARIO
token READ
token ID
token SEMI
	 read variable
	 secuencia sentencias
token ID
token ASSIGN
token CALL
token ID
token LPAREN
token ID
token COMMA
	 identificador
token ID
token RPAREN
	 identificador
	 lista argumentos
token SEMI
	 llamada funcion en expresion
	 asignacion variable
	 secuencia sentencias
token WRITE
token ID
token SEMI
	 identificador
	 write expresion
	 secuencia sentencias
token WRITE
token ID
token COMENTARIO
token END
	 identificador
	 write expresion
	 secuencia sentencias
	 programa principal
	 regla programa completo

IMPRESION DEL AST GENERADO

  Tipo de nodo desconocido
*** Tabla de Simbolos ***
Total de posiciones de memoria utilizadas: 11
Variable: suma -> Direccion: 8
Variable: a -> Direccion: 6
Variable: temp -> Direccion: 4
Variable: b -> Direccion: 7
Variable: resultado -> Direccion: 1
Variable: contador -> Direccion: 0
Variable: factorial -> Direccion: 2
Variable: sumar -> Direccion: 5
Variable: x -> Direccion: 9
Variable: y -> Direccion: 10
Variable: n -> Direccion: 3


------ CODIGO OBJETO DEL LENGUAJE TINY GENERADO PARA LA TM ------


* * Compilacion TINY para la maquina TM
* * Prefacio estandar
0:      LDC       5,0(0)        init: GP = 0
1:      LDC       6,1023(0)      init: MP = 1023 (tope de memoria)
* * Fin del prefacio estandar
* -> programa
* -> declaracion: contador
* Declaracion de variable: contador (global)
2:      LDC       0,0(0)        global: inicializar variable contador a cero
3:      ST        0,0(5)        global: almacenar en direccion 0
* <- declaracion
* -> declaracion: resultado
* Declaracion de variable: resultado (global)
4:      LDC       0,0(0)        global: inicializar variable resultado a cero
5:      ST        0,1(5)        global: almacenar en direccion 1
* <- declaracion
* registrada funcion: factorial
* registrada funcion: sumar
* -> declaracion: x
* Declaracion de variable: x (local)
6:      LDC       0,0(0)        local: inicializar variable x a cero
7:      ST        0,9(5)        local: almacenar en direccion 9
* <- declaracion
* -> declaracion: y
* Declaracion de variable: y (local)
8:      LDC       0,0(0)        local: inicializar variable y a cero
9:      ST        0,10(5)       local: almacenar en direccion 10
* <- declaracion
* -> asignacion
* -> constante
10:     LDC       0,0(0)        cargar constante: 0
* <- constante
11:     ST        0,0(5)        asignacion: almaceno el valor para el id contador
* <- asignacion
* -> leer
12:     IN        0,0,0         leer: lee un valor entero 
13:     ST        0,9(5)        leer: almaceno el valor entero leido en el id x
* <- leer
* -> asignacion
* -> llamada funcion: factorial
* Procesando argumentos de la llamada
* -> identificador
14:     LD        0,9(5)        cargar id: val[x]
* <- identificador
15:     ST        0,0(6)        call: guardar argumento
16:     LDA       0,3(7)        call: calcular return addr (PC+3)
17:     ST        0,-1(6)       call: push return addr
19:     LD        1,-1(6)       prologo: cargar RA de -(numArgs)(MP)
20:     ST        1,0(6)        prologo: colocar RA en 0(MP)
21:     LD        0,0(6)        prologo: cargar arg n
22:     ST        0,3(5)        prologo: guardar param n
* === INICIO FUNCION factorial ===
* -> declaracion: temp
* Declaracion de variable: temp (local)
23:     LDC       0,0(0)        local: inicializar variable temp a cero
24:     ST        0,4(5)        local: almacenar en direccion 4
* <- declaracion
* -> asignacion
* -> Operacion: mas
* -> identificador
25:     LD        0,0(5)        cargar id: val[contador]
* <- identificador
26:     ST        0,-2(6)       op: push en la pila tmp el resultado expresion izquierda
* -> constante
27:     LDC       0,1(0)        cargar constante: 1
* <- constante
28:     LD        1,-2(6)       op: pop o cargo de la pila el valor izquierdo en AC1
29:     ADD       0,1,0         op: +
* <- Operacion: mas
30:     ST        0,0(5)        asignacion: almaceno el valor para el id contador
* <- asignacion
* -> if
* -> Operacion: menorigual
* -> identificador
31:     LD        0,3(5)        cargar id: val[n]
* <- identificador
32:     ST        0,-2(6)       op: push en la pila tmp el resultado expresion izquierda
* -> constante
33:     LDC       0,1(0)        cargar constante: 1
* <- constante
34:     LD        1,-2(6)       op: pop o cargo de la pila el valor izquierdo en AC1
35:     SUB       0,1,0         op: <=
36:     JLE       0,2(7)        saltar si AC<=0
37:     LDC       0,0(0)        caso falso
38:     LDA       7,1(7)        saltar caso verdadero
39:     LDC       0,1(0)        caso verdadero
* <- Operacion: menorigual
* If: el salto hacia el else debe estar aqui
* -> asignacion
* -> constante
41:     LDC       0,1(0)        cargar constante: 1
* <- constante
42:     ST        0,4(5)        asignacion: almaceno el valor para el id temp
* <- asignacion
* If: el salto hacia el final debe estar aqui
40:     JEQ       0,3(7)        if: jmp hacia else
* -> asignacion
* -> Operacion: por
* -> identificador
44:     LD        0,3(5)        cargar id: val[n]
* <- identificador
45:     ST        0,-2(6)       op: push en la pila tmp el resultado expresion izquierda
* -> llamada funcion: factorial
* Procesando argumentos de la llamada
* -> Operacion: menos
* -> identificador
46:     LD        0,3(5)        cargar id: val[n]
* <- identificador
47:     ST        0,-3(6)       op: push en la pila tmp el resultado expresion izquierda
* -> constante
48:     LDC       0,1(0)        cargar constante: 1
* <- constante
49:     LD        1,-3(6)       op: pop o cargo de la pila el valor izquierdo en AC1
50:     SUB       0,1,0         op: -
* <- Operacion: menos
51:     ST        0,-3(6)       call: guardar argumento
52:     LDA       0,3(7)        call: calcular return addr (PC+3)
53:     ST        0,-4(6)       call: push return addr
54:     LDA       7,-36(7)      call: salto a funcion factorial
* <- llamada funcion
55:     LD        1,-3(6)       op: pop o cargo de la pila el valor izquierdo en AC1
56:     MUL       0,1,0         op: *
* <- Operacion: por
57:     ST        0,4(5)        asignacion: almaceno el valor para el id temp
* <- asignacion
43:     LDA       7,14(7)       if: jmp hacia el final
* <- if
* -> return
* -> identificador
58:     LD        0,4(5)        cargar id: val[temp]
* <- identificador
59:     LD        1,0(6)        return: recuperar direccion de retorno
60:     LDA       7,0(1)        return: salto a direccion de retorno
* <- return
* Return implicito de funcion
61:     LD        1,0(6)        funcion: recuperar direccion de retorno
62:     LDA       7,0(1)        funcion: retorno
* === FIN FUNCION factorial ===
18:     LDA       7,0(7)        call: salto a funcion factorial
* <- llamada funcion
63:     ST        0,1(5)        asignacion: almaceno el valor para el id resultado
* <- asignacion
* -> escribir
* -> identificador
64:     LD        0,1(5)        cargar id: val[resultado]
* <- identificador
65:     OUT       0,0,0         escribir: genero la salida de la expresion
* <- escribir
* -> escribir
* -> identificador
66:     LD        0,0(5)        cargar id: val[contador]
* <- identificador
67:     OUT       0,0,0         escribir: genero la salida de la expresion
* <- escribir
* -> leer
68:     IN        0,0,0         leer: lee un valor entero 
69:     ST        0,10(5)       leer: almaceno el valor entero leido en el id y
* <- leer
* -> asignacion
* -> llamada funcion: sumar
* Procesando argumentos de la llamada
* -> identificador
70:     LD        0,9(5)        cargar id: val[x]
* <- identificador
* -> identificador
71:     LD        0,10(5)       cargar id: val[y]
* <- identificador
72:     ST        0,-2(6)       call: guardar argumento
* -> identificador
73:     LD        0,10(5)       cargar id: val[y]
* <- identificador
74:     ST        0,-3(6)       call: guardar argumento
75:     LDA       0,3(7)        call: calcular return addr (PC+3)
76:     ST        0,-4(6)       call: push return addr
78:     LD        1,-2(6)       prologo: cargar RA de -(numArgs)(MP)
79:     ST        1,0(6)        prologo: colocar RA en 0(MP)
80:     LD        0,0(6)        prologo: cargar arg a
81:     ST        0,6(5)        prologo: guardar param a
82:     LD        0,-1(6)       prologo: cargar arg b
83:     ST        0,7(5)        prologo: guardar param b
* === INICIO FUNCION sumar ===
* -> declaracion: suma
* Declaracion de variable: suma (local)
84:     LDC       0,0(0)        local: inicializar variable suma a cero
85:     ST        0,8(5)        local: almacenar en direccion 8
* <- declaracion
* -> asignacion
* -> Operacion: mas
* -> identificador
86:     LD        0,6(5)        cargar id: val[a]
* <- identificador
87:     ST        0,-5(6)       op: push en la pila tmp el resultado expresion izquierda
* -> identificador
88:     LD        0,7(5)        cargar id: val[b]
* <- identificador
89:     LD        1,-5(6)       op: pop o cargo de la pila el valor izquierdo en AC1
90:     ADD       0,1,0         op: +
* <- Operacion: mas
91:     ST        0,8(5)        asignacion: almaceno el valor para el id suma
* <- asignacion
* -> asignacion
* -> Operacion: mas
* -> identificador
92:     LD        0,0(5)        cargar id: val[contador]
* <- identificador
93:     ST        0,-5(6)       op: push en la pila tmp el resultado expresion izquierda
* -> constante
94:     LDC       0,1(0)        cargar constante: 1
* <- constante
95:     LD        1,-5(6)       op: pop o cargo de la pila el valor izquierdo en AC1
96:     ADD       0,1,0         op: +
* <- Operacion: mas
97:     ST        0,0(5)        asignacion: almaceno el valor para el id contador
* <- asignacion
* -> return
* -> identificador
98:     LD        0,8(5)        cargar id: val[suma]
* <- identificador
99:     LD        1,0(6)        return: recuperar direccion de retorno
100:    LDA       7,0(1)        return: salto a direccion de retorno
* <- return
* Return implicito de funcion
101:    LD        1,0(6)        funcion: recuperar direccion de retorno
102:    LDA       7,0(1)        funcion: retorno
* === FIN FUNCION sumar ===
77:     LDA       7,0(7)        call: salto a funcion sumar
* <- llamada funcion
103:    ST        0,1(5)        asignacion: almaceno el valor para el id resultado
* <- asignacion
* -> escribir
* -> identificador
104:    LD        0,1(5)        cargar id: val[resultado]
* <- identificador
105:    OUT       0,0,0         escribir: genero la salida de la expresion
* <- escribir
* -> escribir
* -> identificador
106:    LD        0,0(5)        cargar id: val[contador]
* <- identificador
107:    OUT       0,0,0         escribir: genero la salida de la expresion
* <- escribir
* <- programa
* Fin de la ejecucion.
108:    HALT      0,0,0         


------ FIN DEL CODIGO OBJETO DEL LENGUAJE TINY GENERADO PARA LA TM ------

Generando archivo de código objeto: ejemplo_generado/test_funciones_completo.tm
Generando código objeto en archivo: ejemplo_generado/test_funciones_completo.tm
Archivo ejemplo_generado/test_funciones_completo.tm generado exitosamente.
