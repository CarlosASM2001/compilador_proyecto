token COMENTARIO
token BEGIN
token VAR
token ID
token SEMI
token VAR
	 declaracion variable local
	 sentencia unica
token ID
token SEMI
token VAR
	 declaracion variable local
	 secuencia sentencias sin punto y coma
token ID
token SEMI
token VAR
	 declaracion variable local
	 secuencia sentencias sin punto y coma
token ID
token SEMI
token READ
	 declaracion variable local
	 secuencia sentencias sin punto y coma
token ID
token SEMI
	 read variable
	 secuencia sentencias sin punto y coma
token READ
token ID
token SEMI
	 read variable
	 secuencia sentencias
token COMENTARIO_LINEA
token WRITE
token ID
token GT
	 identificador
token ID
token SEMI
	 identificador
	 operacion mayor
	 write expresion
	 secuencia sentencias
token WRITE
token ID
token GE
	 identificador
token ID
token SEMI
	 identificador
	 operacion mayor igual
	 write expresion
	 secuencia sentencias
token WRITE
token ID
token LE
	 identificador
token ID
token SEMI
	 identificador
	 operacion menor igual
	 write expresion
	 secuencia sentencias
token WRITE
token ID
token NE
	 identificador
token ID
token SEMI
	 identificador
	 operacion diferente
	 write expresion
	 secuencia sentencias
token WRITE
token ID
token EQ
	 identificador
token ID
token SEMI
	 identificador
	 operacion igual
	 write expresion
	 secuencia sentencias
token COMENTARIO_LINEA
token WRITE
token ID
token PLUS
	 identificador
token ID
token SEMI
	 identificador
	 suma
	 write expresion
	 secuencia sentencias
token WRITE
token ID
token MINUS
	 identificador
token ID
token SEMI
	 identificador
	 resta
	 write expresion
	 secuencia sentencias
token WRITE
token ID
token TIMES
	 identificador
token ID
token SEMI
	 identificador
	 multiplicacion
	 write expresion
	 secuencia sentencias
token IF
token ID
token NE
	 identificador
token NUM
token THEN
	 numero entero
	 operacion diferente
token WRITE
token ID
token OVER
	 identificador
token ID
token END
	 identificador
	 division
	 write expresion
	 sentencia unica
token SEMI
	 if simple
	 secuencia sentencias
token WRITE
token ID
token MOD
	 identificador
token ID
token SEMI
	 identificador
	 modulo
	 write expresion
	 secuencia sentencias
token WRITE
token ID
token POW
	 identificador
token NUM
token SEMI
	 numero entero
	 potencia
	 write expresion
	 secuencia sentencias
token COMENTARIO_LINEA
token ID
token ASSIGN
token ID
token LE
	 identificador
token ID
token SEMI
	 identificador
	 operacion menor igual
	 asignacion variable
	 secuencia sentencias
token ID
token ASSIGN
token ID
token GE
	 identificador
token ID
token SEMI
	 identificador
	 operacion mayor igual
	 asignacion variable
	 secuencia sentencias
token WRITE
token ID
token AND
	 identificador
token ID
token SEMI
	 identificador
	 operacion AND
	 write expresion
	 secuencia sentencias
token WRITE
token ID
token OR
	 identificador
token ID
token SEMI
	 identificador
	 operacion OR
	 write expresion
	 secuencia sentencias
token WRITE
token NOT
token ID
token SEMI
	 identificador
	 operacion NOT
	 write expresion
	 secuencia sentencias
token END
Syntax error
instead expected token classes are [error, IF, REPEAT, READ, WRITE, RETURN, CALL, VAR, FOR, BREAK, CONTINUE, ID]
	 error en sentencia
Error sintáctico en sentencia
	 secuencia sentencias
	 programa principal
	 regla programa solo main

IMPRESION DEL AST GENERADO

  Tipo de nodo desconocido
*** Tabla de Simbolos ***
Total de posiciones de memoria utilizadas: 4
Variable: a -> Direccion: 2
Variable: b -> Direccion: 3
Variable: x -> Direccion: 0
Variable: y -> Direccion: 1


------ CODIGO OBJETO DEL LENGUAJE TINY GENERADO PARA LA TM ------


* * Compilacion TINY para la maquina TM
* * Prefacio estandar
0:      LDC       5,0(0)        init: GP = 0
1:      LDC       6,1023(0)      init: MP = 1023 (tope de memoria)
* * Fin del prefacio estandar
* -> programa
* -> declaracion: x
* Declaracion de variable: x (local)
2:      LDC       0,0(0)        local: inicializar variable x a cero
3:      ST        0,0(5)        local: almacenar en direccion 0
* <- declaracion
* -> declaracion: y
* Declaracion de variable: y (local)
4:      LDC       0,0(0)        local: inicializar variable y a cero
5:      ST        0,1(5)        local: almacenar en direccion 1
* <- declaracion
* -> declaracion: a
* Declaracion de variable: a (local)
6:      LDC       0,0(0)        local: inicializar variable a a cero
7:      ST        0,2(5)        local: almacenar en direccion 2
* <- declaracion
* -> declaracion: b
* Declaracion de variable: b (local)
8:      LDC       0,0(0)        local: inicializar variable b a cero
9:      ST        0,3(5)        local: almacenar en direccion 3
* <- declaracion
* -> leer
10:     IN        0,0,0         leer: lee un valor entero 
11:     ST        0,0(5)        leer: almaceno el valor entero leido en el id x
* <- leer
* -> leer
12:     IN        0,0,0         leer: lee un valor entero 
13:     ST        0,1(5)        leer: almaceno el valor entero leido en el id y
* <- leer
* -> escribir
* -> Operacion: mayor
* -> identificador
14:     LD        0,0(5)        cargar id: val[x]
* <- identificador
15:     ST        0,0(6)        op: push en la pila tmp el resultado expresion izquierda
* -> identificador
16:     LD        0,1(5)        cargar id: val[y]
* <- identificador
17:     LD        1,0(6)        op: pop o cargo de la pila el valor izquierdo en AC1
18:     SUB       0,1,0         op: >
19:     JGT       0,2(7)        saltar si AC>0
20:     LDC       0,0(0)        caso falso
21:     LDA       7,1(7)        saltar caso verdadero
22:     LDC       0,1(0)        caso verdadero
* <- Operacion: mayor
23:     OUT       0,0,0         escribir: genero la salida de la expresion
* <- escribir
* -> escribir
* -> Operacion: mayorigual
* -> identificador
24:     LD        0,0(5)        cargar id: val[x]
* <- identificador
25:     ST        0,0(6)        op: push en la pila tmp el resultado expresion izquierda
* -> identificador
26:     LD        0,1(5)        cargar id: val[y]
* <- identificador
27:     LD        1,0(6)        op: pop o cargo de la pila el valor izquierdo en AC1
28:     SUB       0,1,0         op: >=
29:     JGE       0,2(7)        saltar si AC>=0
30:     LDC       0,0(0)        caso falso
31:     LDA       7,1(7)        saltar caso verdadero
32:     LDC       0,1(0)        caso verdadero
* <- Operacion: mayorigual
33:     OUT       0,0,0         escribir: genero la salida de la expresion
* <- escribir
* -> escribir
* -> Operacion: menorigual
* -> identificador
34:     LD        0,0(5)        cargar id: val[x]
* <- identificador
35:     ST        0,0(6)        op: push en la pila tmp el resultado expresion izquierda
* -> identificador
36:     LD        0,1(5)        cargar id: val[y]
* <- identificador
37:     LD        1,0(6)        op: pop o cargo de la pila el valor izquierdo en AC1
38:     SUB       0,1,0         op: <=
39:     JLE       0,2(7)        saltar si AC<=0
40:     LDC       0,0(0)        caso falso
41:     LDA       7,1(7)        saltar caso verdadero
42:     LDC       0,1(0)        caso verdadero
* <- Operacion: menorigual
43:     OUT       0,0,0         escribir: genero la salida de la expresion
* <- escribir
* -> escribir
* -> Operacion: diferente
* -> identificador
44:     LD        0,0(5)        cargar id: val[x]
* <- identificador
45:     ST        0,0(6)        op: push en la pila tmp el resultado expresion izquierda
* -> identificador
46:     LD        0,1(5)        cargar id: val[y]
* <- identificador
47:     LD        1,0(6)        op: pop o cargo de la pila el valor izquierdo en AC1
48:     SUB       0,1,0         op: !=
49:     JNE       0,2(7)        saltar si AC!=0
50:     LDC       0,0(0)        caso falso
51:     LDA       7,1(7)        saltar caso verdadero
52:     LDC       0,1(0)        caso verdadero
* <- Operacion: diferente
53:     OUT       0,0,0         escribir: genero la salida de la expresion
* <- escribir
* -> escribir
* -> Operacion: igual
* -> identificador
54:     LD        0,0(5)        cargar id: val[x]
* <- identificador
55:     ST        0,0(6)        op: push en la pila tmp el resultado expresion izquierda
* -> identificador
56:     LD        0,1(5)        cargar id: val[y]
* <- identificador
57:     LD        1,0(6)        op: pop o cargo de la pila el valor izquierdo en AC1
58:     SUB       0,1,0         op: ==
59:     JEQ       0,2(7)        voy dos instrucciones mas alla if verdadero (AC==0)
60:     LDC       0,0(0)        caso de falso (AC=0)
61:     LDA       7,1(7)        Salto incodicional a direccion: PC+1 (es falso evito colocarlo verdadero)
62:     LDC       0,1(0)        caso de verdadero (AC=1)
* <- Operacion: igual
63:     OUT       0,0,0         escribir: genero la salida de la expresion
* <- escribir
* -> escribir
* -> Operacion: mas
* -> identificador
64:     LD        0,0(5)        cargar id: val[x]
* <- identificador
65:     ST        0,0(6)        op: push en la pila tmp el resultado expresion izquierda
* -> identificador
66:     LD        0,1(5)        cargar id: val[y]
* <- identificador
67:     LD        1,0(6)        op: pop o cargo de la pila el valor izquierdo en AC1
68:     ADD       0,1,0         op: +
* <- Operacion: mas
69:     OUT       0,0,0         escribir: genero la salida de la expresion
* <- escribir
* -> escribir
* -> Operacion: menos
* -> identificador
70:     LD        0,0(5)        cargar id: val[x]
* <- identificador
71:     ST        0,0(6)        op: push en la pila tmp el resultado expresion izquierda
* -> identificador
72:     LD        0,1(5)        cargar id: val[y]
* <- identificador
73:     LD        1,0(6)        op: pop o cargo de la pila el valor izquierdo en AC1
74:     SUB       0,1,0         op: -
* <- Operacion: menos
75:     OUT       0,0,0         escribir: genero la salida de la expresion
* <- escribir
* -> escribir
* -> Operacion: por
* -> identificador
76:     LD        0,0(5)        cargar id: val[x]
* <- identificador
77:     ST        0,0(6)        op: push en la pila tmp el resultado expresion izquierda
* -> identificador
78:     LD        0,1(5)        cargar id: val[y]
* <- identificador
79:     LD        1,0(6)        op: pop o cargo de la pila el valor izquierdo en AC1
80:     MUL       0,1,0         op: *
* <- Operacion: por
81:     OUT       0,0,0         escribir: genero la salida de la expresion
* <- escribir
* -> if
* -> Operacion: diferente
* -> identificador
82:     LD        0,1(5)        cargar id: val[y]
* <- identificador
83:     ST        0,0(6)        op: push en la pila tmp el resultado expresion izquierda
* -> constante
84:     LDC       0,0(0)        cargar constante: 0
* <- constante
85:     LD        1,0(6)        op: pop o cargo de la pila el valor izquierdo en AC1
86:     SUB       0,1,0         op: !=
87:     JNE       0,2(7)        saltar si AC!=0
88:     LDC       0,0(0)        caso falso
89:     LDA       7,1(7)        saltar caso verdadero
90:     LDC       0,1(0)        caso verdadero
* <- Operacion: diferente
* If: el salto hacia el else debe estar aqui
* -> escribir
* -> Operacion: entre
* -> identificador
92:     LD        0,0(5)        cargar id: val[x]
* <- identificador
93:     ST        0,0(6)        op: push en la pila tmp el resultado expresion izquierda
* -> identificador
94:     LD        0,1(5)        cargar id: val[y]
* <- identificador
95:     LD        1,0(6)        op: pop o cargo de la pila el valor izquierdo en AC1
96:     DIV       0,1,0         op: /
* <- Operacion: entre
97:     OUT       0,0,0         escribir: genero la salida de la expresion
* <- escribir
91:     JEQ       0,6(7)        if: jmp hacia el final
* <- if
* -> escribir
* -> Operacion: modulo
* -> identificador
98:     LD        0,0(5)        cargar id: val[x]
* <- identificador
99:     ST        0,0(6)        op: push en la pila tmp el resultado expresion izquierda
* -> identificador
100:    LD        0,1(5)        cargar id: val[y]
* <- identificador
101:    LD        1,0(6)        op: pop o cargo de la pila el valor izquierdo en AC1
102:    ST        0,0(6)        mod: guardar b
103:    ST        1,-1(6)       mod: guardar a
104:    DIV       0,1,0         mod: a/b
105:    LD        1,-1(6)       mod: recuperar a
106:    LD        2,0(6)        mod: recuperar b en r2
107:    MUL       0,0,2         mod: (a/b)*b
108:    SUB       0,1,0         mod: a - (a/b)*b
* <- Operacion: modulo
109:    OUT       0,0,0         escribir: genero la salida de la expresion
* <- escribir
* -> escribir
* -> Operacion: potencia
* -> identificador
110:    LD        0,0(5)        cargar id: val[x]
* <- identificador
111:    ST        0,0(6)        op: push en la pila tmp el resultado expresion izquierda
* -> constante
112:    LDC       0,2(0)        cargar constante: 2
* <- constante
113:    LD        1,0(6)        op: pop o cargo de la pila el valor izquierdo en AC1
114:    ST        0,0(6)        pow: guardar exp
115:    ST        1,-1(6)       pow: guardar base
116:    LDC       0,1(0)        pow: inicializar resultado = 1
117:    ST        0,-2(6)       pow: guardar res
* pow: inicio bucle
118:    LD        0,0(6)        pow: cargar exp
* pow: salto condicional a fin (exp==0)
120:    LD        0,-2(6)       pow: cargar res
121:    LD        1,-1(6)       pow: cargar base
122:    MUL       0,1,0         pow: res = res * base
123:    ST        0,-2(6)       pow: guardar res
124:    LD        1,0(6)        pow: cargar exp en AC1
125:    LDC       0,1(0)        pow: cargar 1
126:    SUB       0,1,0         pow: exp - 1
127:    ST        0,0(6)        pow: guardar exp
128:    LDA       7,-11(7)      pow: repetir
119:    JEQ       0,9(7)        pow: salir si exp == 0
129:    LD        0,-2(6)       pow: cargar resultado
130:    LD        1,-2(6)       pow: pop res
131:    LD        1,-1(6)       pow: pop base
132:    LD        1,0(6)        pow: pop exp
* <- Operacion: potencia
133:    OUT       0,0,0         escribir: genero la salida de la expresion
* <- escribir
* -> asignacion
* -> Operacion: menorigual
* -> identificador
134:    LD        0,0(5)        cargar id: val[x]
* <- identificador
135:    ST        0,0(6)        op: push en la pila tmp el resultado expresion izquierda
* -> identificador
136:    LD        0,1(5)        cargar id: val[y]
* <- identificador
137:    LD        1,0(6)        op: pop o cargo de la pila el valor izquierdo en AC1
138:    SUB       0,1,0         op: <=
139:    JLE       0,2(7)        saltar si AC<=0
140:    LDC       0,0(0)        caso falso
141:    LDA       7,1(7)        saltar caso verdadero
142:    LDC       0,1(0)        caso verdadero
* <- Operacion: menorigual
143:    ST        0,2(5)        asignacion: almaceno el valor para el id a
* <- asignacion
* -> asignacion
* -> Operacion: mayorigual
* -> identificador
144:    LD        0,0(5)        cargar id: val[x]
* <- identificador
145:    ST        0,0(6)        op: push en la pila tmp el resultado expresion izquierda
* -> identificador
146:    LD        0,1(5)        cargar id: val[y]
* <- identificador
147:    LD        1,0(6)        op: pop o cargo de la pila el valor izquierdo en AC1
148:    SUB       0,1,0         op: >=
149:    JGE       0,2(7)        saltar si AC>=0
150:    LDC       0,0(0)        caso falso
151:    LDA       7,1(7)        saltar caso verdadero
152:    LDC       0,1(0)        caso verdadero
* <- Operacion: mayorigual
153:    ST        0,3(5)        asignacion: almaceno el valor para el id b
* <- asignacion
* -> escribir
* -> Operacion: and
* -> identificador
154:    LD        0,2(5)        cargar id: val[a]
* <- identificador
155:    ST        0,0(6)        op: push en la pila tmp el resultado expresion izquierda
* -> identificador
156:    LD        0,3(5)        cargar id: val[b]
* <- identificador
157:    LD        1,0(6)        op: pop o cargo de la pila el valor izquierdo en AC1
158:    JEQ       1,3(7)        and: si izquierdo es falso, resultado es falso
159:    JEQ       0,2(7)        and: si derecho es falso, resultado es falso
160:    LDC       0,1(0)        and: ambos verdaderos
161:    LDA       7,1(7)        and: saltar caso falso
162:    LDC       0,0(0)        and: resultado falso
* <- Operacion: and
163:    OUT       0,0,0         escribir: genero la salida de la expresion
* <- escribir
* -> escribir
* -> Operacion: or
* -> identificador
164:    LD        0,2(5)        cargar id: val[a]
* <- identificador
165:    ST        0,0(6)        op: push en la pila tmp el resultado expresion izquierda
* -> identificador
166:    LD        0,3(5)        cargar id: val[b]
* <- identificador
167:    LD        1,0(6)        op: pop o cargo de la pila el valor izquierdo en AC1
168:    JNE       1,3(7)        or: si izquierdo es verdadero, resultado es verdadero
169:    JNE       0,2(7)        or: si derecho es verdadero, resultado es verdadero
170:    LDC       0,0(0)        or: ambos falsos
171:    LDA       7,1(7)        or: saltar caso verdadero
172:    LDC       0,1(0)        or: resultado verdadero
* <- Operacion: or
173:    OUT       0,0,0         escribir: genero la salida de la expresion
* <- escribir
* -> escribir
* -> Operacion: not
* -> identificador
174:    LD        0,2(5)        cargar id: val[a]
* <- identificador
175:    JEQ       0,2(7)        not: saltar si es cero (falso)
176:    LDC       0,0(0)        not: resultado falso
177:    LDA       7,1(7)        not: saltar carga de verdadero
178:    LDC       0,1(0)        not: resultado verdadero
* <- Operacion: not
179:    OUT       0,0,0         escribir: genero la salida de la expresion
* <- escribir
* <- programa
* Fin de la ejecucion.
180:    HALT      0,0,0         


------ FIN DEL CODIGO OBJETO DEL LENGUAJE TINY GENERADO PARA LA TM ------

Generando archivo de código objeto: ejemplo_generado/ejemplo_operadores.tm
Generando código objeto en archivo: ejemplo_generado/ejemplo_operadores.tm
Archivo ejemplo_generado/ejemplo_operadores.tm generado exitosamente.
