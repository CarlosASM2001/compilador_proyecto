token COMENTARIO
token BEGIN
token VAR
token ID
token COLON
Syntax error
instead expected token classes are []
token ARRAY
token LBRACKET
token NUM
token RBRACKET
token SEMI
token VAR
token ID
token SEMI
	 error en sentencia
Error sintáctico en sentencia
	 sentencia unica
token VAR
	 declaracion variable local
	 secuencia sentencias
token ID
token SEMI
token VAR
	 declaracion variable local
	 secuencia sentencias sin punto y coma
token ID
token SEMI
token ID
	 declaracion variable local
	 secuencia sentencias sin punto y coma
token ASSIGN
token NUM
token SEMI
	 numero entero
	 asignacion variable
	 secuencia sentencias sin punto y coma
token REPEAT
token READ
token ID
token LBRACKET
Syntax error
instead expected token classes are [error, IF, REPEAT, UNTIL, READ, WRITE, RETURN, CALL, VAR, FOR, BREAK, CONTINUE, SEMI, ID]
token ID
token RBRACKET
token SEMI
token ID
token ASSIGN
token ID
	 error en sentencia
Error sintáctico en sentencia
	 sentencia unica
token PLUS
	 identificador
token NUM
token UNTIL
	 numero entero
	 suma
	 asignacion variable
	 secuencia sentencias
token ID
token EQ
	 identificador
token NUM
token SEMI
	 numero entero
	 operacion igual
	 repeat-until
	 secuencia sentencias
token ID
token ASSIGN
token ID
token LBRACKET
token NUM
token RBRACKET
	 numero entero
token PLUS
	 acceso array
token ID
token LBRACKET
token NUM
token RBRACKET
	 numero entero
token PLUS
	 acceso array
	 suma
token ID
token LBRACKET
token NUM
token RBRACKET
	 numero entero
token PLUS
	 acceso array
	 suma
token ID
token LBRACKET
token NUM
token RBRACKET
	 numero entero
token PLUS
	 acceso array
	 suma
token ID
token LBRACKET
token NUM
token RBRACKET
	 numero entero
token SEMI
	 acceso array
	 suma
	 asignacion variable
	 secuencia sentencias
token ID
token ASSIGN
token ID
token LBRACKET
token NUM
token RBRACKET
	 numero entero
token SEMI
	 acceso array
	 asignacion variable
	 secuencia sentencias
token ID
token ASSIGN
token NUM
token SEMI
	 numero entero
	 asignacion variable
	 secuencia sentencias
token REPEAT
token IF
token ID
token LBRACKET
token ID
token RBRACKET
	 identificador
token LT
	 acceso array
token ID
token THEN
	 identificador
	 operacion menor
token ID
token ASSIGN
token ID
token LBRACKET
token ID
token RBRACKET
	 identificador
token END
	 acceso array
	 asignacion variable
	 sentencia unica
token SEMI
	 if simple
	 sentencia unica
token ID
token ASSIGN
token ID
token PLUS
	 identificador
token NUM
token UNTIL
	 numero entero
	 suma
	 asignacion variable
	 secuencia sentencias
token ID
token EQ
	 identificador
token NUM
token SEMI
	 numero entero
	 operacion igual
	 repeat-until
	 secuencia sentencias
token WRITE
token ID
token SEMI
	 identificador
	 write expresion
	 secuencia sentencias
token WRITE
token ID
token END
	 identificador
	 write expresion
	 secuencia sentencias
	 programa principal
	 regla programa solo main

IMPRESION DEL AST GENERADO

  Tipo de nodo desconocido
*** Tabla de Simbolos ***
Total de posiciones de memoria utilizadas: 4
Variable: suma -> Direccion: 1
Variable: val -> Direccion: 3
Variable: menor -> Direccion: 0
Variable: i -> Direccion: 2


------ CODIGO OBJETO DEL LENGUAJE TINY GENERADO PARA LA TM ------


* * Compilacion TINY para la maquina TM
* * Prefacio estandar
0:      LDC       5,0(0)        init: GP = 0
1:      LDC       6,1023(0)      init: MP = 1023 (tope de memoria)
* * Fin del prefacio estandar
* -> programa
* -> declaracion: menor
* Declaracion de variable: menor (local)
2:      LDC       0,0(0)        local: inicializar variable menor a cero
3:      ST        0,0(5)        local: almacenar en direccion 0
* <- declaracion
* -> declaracion: suma
* Declaracion de variable: suma (local)
4:      LDC       0,0(0)        local: inicializar variable suma a cero
5:      ST        0,1(5)        local: almacenar en direccion 1
* <- declaracion
* -> declaracion: i
* Declaracion de variable: i (local)
6:      LDC       0,0(0)        local: inicializar variable i a cero
7:      ST        0,2(5)        local: almacenar en direccion 2
* <- declaracion
* -> asignacion
* -> constante
8:      LDC       0,0(0)        cargar constante: 0
* <- constante
9:      ST        0,2(5)        asignacion: almaceno el valor para el id i
* <- asignacion
* -> repeat
* repeat: el salto hacia el final (luego del cuerpo) del repeat debe estar aqui
* -> asignacion
* -> Operacion: mas
* -> identificador
10:     LD        0,2(5)        cargar id: val[i]
* <- identificador
11:     ST        0,0(6)        op: push en la pila tmp el resultado expresion izquierda
* -> constante
12:     LDC       0,1(0)        cargar constante: 1
* <- constante
13:     LD        1,0(6)        op: pop o cargo de la pila el valor izquierdo en AC1
14:     ADD       0,1,0         op: +
* <- Operacion: mas
15:     ST        0,2(5)        asignacion: almaceno el valor para el id i
* <- asignacion
* -> Operacion: igual
* -> identificador
16:     LD        0,2(5)        cargar id: val[i]
* <- identificador
17:     ST        0,0(6)        op: push en la pila tmp el resultado expresion izquierda
* -> constante
18:     LDC       0,5(0)        cargar constante: 5
* <- constante
19:     LD        1,0(6)        op: pop o cargo de la pila el valor izquierdo en AC1
20:     SUB       0,1,0         op: ==
21:     JEQ       0,2(7)        voy dos instrucciones mas alla if verdadero (AC==0)
22:     LDC       0,0(0)        caso de falso (AC=0)
23:     LDA       7,1(7)        Salto incodicional a direccion: PC+1 (es falso evito colocarlo verdadero)
24:     LDC       0,1(0)        caso de verdadero (AC=1)
* <- Operacion: igual
25:     JEQ       0,-16(7)      repeat: jmp hacia el inicio del cuerpo
* <- repeat
* -> asignacion
* -> Operacion: mas
* -> Operacion: mas
* -> Operacion: mas
* -> Operacion: mas
* -> identificador
* -> constante
26:     LDC       0,0(0)        cargar constante: 0
* <- constante
27:     LDC       1,3(0)        identificador array: cargar direccion base
28:     ADD       0,0,1         identificador array: calcular direccion
* <- identificador
29:     ST        0,0(6)        op: push en la pila tmp el resultado expresion izquierda
* -> identificador
* -> constante
30:     LDC       0,1(0)        cargar constante: 1
* <- constante
31:     LDC       1,3(0)        identificador array: cargar direccion base
32:     ADD       0,0,1         identificador array: calcular direccion
* <- identificador
33:     LD        1,0(6)        op: pop o cargo de la pila el valor izquierdo en AC1
34:     ADD       0,1,0         op: +
* <- Operacion: mas
35:     ST        0,0(6)        op: push en la pila tmp el resultado expresion izquierda
* -> identificador
* -> constante
36:     LDC       0,2(0)        cargar constante: 2
* <- constante
37:     LDC       1,3(0)        identificador array: cargar direccion base
38:     ADD       0,0,1         identificador array: calcular direccion
* <- identificador
39:     LD        1,0(6)        op: pop o cargo de la pila el valor izquierdo en AC1
40:     ADD       0,1,0         op: +
* <- Operacion: mas
41:     ST        0,0(6)        op: push en la pila tmp el resultado expresion izquierda
* -> identificador
* -> constante
42:     LDC       0,3(0)        cargar constante: 3
* <- constante
43:     LDC       1,3(0)        identificador array: cargar direccion base
44:     ADD       0,0,1         identificador array: calcular direccion
* <- identificador
45:     LD        1,0(6)        op: pop o cargo de la pila el valor izquierdo en AC1
46:     ADD       0,1,0         op: +
* <- Operacion: mas
47:     ST        0,0(6)        op: push en la pila tmp el resultado expresion izquierda
* -> identificador
* -> constante
48:     LDC       0,4(0)        cargar constante: 4
* <- constante
49:     LDC       1,3(0)        identificador array: cargar direccion base
50:     ADD       0,0,1         identificador array: calcular direccion
* <- identificador
51:     LD        1,0(6)        op: pop o cargo de la pila el valor izquierdo en AC1
52:     ADD       0,1,0         op: +
* <- Operacion: mas
53:     ST        0,1(5)        asignacion: almaceno el valor para el id suma
* <- asignacion
* -> asignacion
* -> identificador
* -> constante
54:     LDC       0,0(0)        cargar constante: 0
* <- constante
55:     LDC       1,3(0)        identificador array: cargar direccion base
56:     ADD       0,0,1         identificador array: calcular direccion
* <- identificador
57:     ST        0,0(5)        asignacion: almaceno el valor para el id menor
* <- asignacion
* -> asignacion
* -> constante
58:     LDC       0,1(0)        cargar constante: 1
* <- constante
59:     ST        0,2(5)        asignacion: almaceno el valor para el id i
* <- asignacion
* -> repeat
* repeat: el salto hacia el final (luego del cuerpo) del repeat debe estar aqui
* -> if
* -> Operacion: menor
* -> identificador
* -> identificador
60:     LD        0,2(5)        cargar id: val[i]
* <- identificador
61:     LDC       1,3(0)        identificador array: cargar direccion base
62:     ADD       0,0,1         identificador array: calcular direccion
* <- identificador
63:     ST        0,0(6)        op: push en la pila tmp el resultado expresion izquierda
* -> identificador
64:     LD        0,0(5)        cargar id: val[menor]
* <- identificador
65:     LD        1,0(6)        op: pop o cargo de la pila el valor izquierdo en AC1
66:     SUB       0,1,0         op: <
67:     JLT       0,2(7)        voy dos instrucciones mas alla if verdadero (AC<0)
68:     LDC       0,0(0)        caso de falso (AC=0)
69:     LDA       7,1(7)        Salto incodicional a direccion: PC+1 (es falso evito colocarlo verdadero)
70:     LDC       0,1(0)        caso de verdadero (AC=1)
* <- Operacion: menor
* If: el salto hacia el else debe estar aqui
* -> asignacion
* -> identificador
* -> identificador
72:     LD        0,2(5)        cargar id: val[i]
* <- identificador
73:     LDC       1,3(0)        identificador array: cargar direccion base
74:     ADD       0,0,1         identificador array: calcular direccion
* <- identificador
75:     ST        0,0(5)        asignacion: almaceno el valor para el id menor
* <- asignacion
* If: el salto hacia el final debe estar aqui
71:     JEQ       0,5(7)        if: jmp hacia else
* <- if
* -> asignacion
* -> Operacion: mas
* -> identificador
77:     LD        0,2(5)        cargar id: val[i]
* <- identificador
78:     ST        0,0(6)        op: push en la pila tmp el resultado expresion izquierda
* -> constante
79:     LDC       0,1(0)        cargar constante: 1
* <- constante
80:     LD        1,0(6)        op: pop o cargo de la pila el valor izquierdo en AC1
81:     ADD       0,1,0         op: +
* <- Operacion: mas
82:     ST        0,2(5)        asignacion: almaceno el valor para el id i
* <- asignacion
* -> Operacion: igual
* -> identificador
83:     LD        0,2(5)        cargar id: val[i]
* <- identificador
84:     ST        0,0(6)        op: push en la pila tmp el resultado expresion izquierda
* -> constante
85:     LDC       0,5(0)        cargar constante: 5
* <- constante
86:     LD        1,0(6)        op: pop o cargo de la pila el valor izquierdo en AC1
87:     SUB       0,1,0         op: ==
88:     JEQ       0,2(7)        voy dos instrucciones mas alla if verdadero (AC==0)
89:     LDC       0,0(0)        caso de falso (AC=0)
90:     LDA       7,1(7)        Salto incodicional a direccion: PC+1 (es falso evito colocarlo verdadero)
91:     LDC       0,1(0)        caso de verdadero (AC=1)
* <- Operacion: igual
92:     JEQ       0,-33(7)      repeat: jmp hacia el inicio del cuerpo
* <- repeat
* -> escribir
* -> identificador
93:     LD        0,1(5)        cargar id: val[suma]
* <- identificador
94:     OUT       0,0,0         escribir: genero la salida de la expresion
* <- escribir
* -> escribir
* -> identificador
95:     LD        0,0(5)        cargar id: val[menor]
* <- identificador
96:     OUT       0,0,0         escribir: genero la salida de la expresion
* <- escribir
* <- programa
* Fin de la ejecucion.
97:     HALT      0,0,0         


------ FIN DEL CODIGO OBJETO DEL LENGUAJE TINY GENERADO PARA LA TM ------

Generando archivo de código objeto: ejemplo_generado/ejemplo_vectores.tm
Generando código objeto en archivo: ejemplo_generado/ejemplo_vectores.tm
Archivo ejemplo_generado/ejemplo_vectores.tm generado exitosamente.
