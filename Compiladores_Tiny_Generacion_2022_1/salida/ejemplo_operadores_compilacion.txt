token COMENTARIO
token BEGIN
token VAR
token ID
token SEMI
token VAR
	 declaracion variable local
	 sentencia unica
token ID
token SEMI
token VAR
	 declaracion variable local
	 secuencia sentencias sin punto y coma
token ID
token SEMI
token VAR
	 declaracion variable local
	 secuencia sentencias sin punto y coma
token ID
token SEMI
token READ
	 declaracion variable local
	 secuencia sentencias sin punto y coma
token ID
token SEMI
	 read variable
	 secuencia sentencias sin punto y coma
token READ
token ID
token SEMI
	 read variable
	 secuencia sentencias
token COMENTARIO_LINEA
token WRITE
token ID
token GT
	 identificador
token ID
token SEMI
	 identificador
	 operacion mayor
	 write expresion
	 secuencia sentencias
token WRITE
token ID
token GE
	 identificador
token ID
token SEMI
	 identificador
	 operacion mayor igual
	 write expresion
	 secuencia sentencias
token WRITE
token ID
token LE
	 identificador
token ID
token SEMI
	 identificador
	 operacion menor igual
	 write expresion
	 secuencia sentencias
token WRITE
token ID
token NE
	 identificador
token ID
token SEMI
	 identificador
	 operacion diferente
	 write expresion
	 secuencia sentencias
token WRITE
token ID
token EQ
	 identificador
token ID
token SEMI
	 identificador
	 operacion igual
	 write expresion
	 secuencia sentencias
token COMENTARIO_LINEA
token WRITE
token ID
token PLUS
	 identificador
token ID
token SEMI
	 identificador
	 suma
	 write expresion
	 secuencia sentencias
token WRITE
token ID
token MINUS
	 identificador
token ID
token SEMI
	 identificador
	 resta
	 write expresion
	 secuencia sentencias
token WRITE
token ID
token TIMES
	 identificador
token ID
token SEMI
	 identificador
	 multiplicacion
	 write expresion
	 secuencia sentencias
token IF
token ID
token NE
	 identificador
token NUM
token THEN
	 numero entero
	 operacion diferente
token WRITE
token ID
token OVER
	 identificador
token ID
token END
	 identificador
	 division
	 write expresion
	 sentencia unica
token SEMI
	 if simple
	 secuencia sentencias
token WRITE
token ID
token MOD
	 identificador
token ID
token SEMI
	 identificador
	 modulo
	 write expresion
	 secuencia sentencias
token WRITE
token ID
token POW
	 identificador
token NUM
token SEMI
	 numero entero
	 potencia
	 write expresion
	 secuencia sentencias
token COMENTARIO_LINEA
token ID
token ASSIGN
token ID
token LE
	 identificador
token ID
token SEMI
	 identificador
	 operacion menor igual
	 asignacion variable
	 secuencia sentencias
token ID
token ASSIGN
token ID
token GE
	 identificador
token ID
token SEMI
	 identificador
	 operacion mayor igual
	 asignacion variable
	 secuencia sentencias
token WRITE
token ID
token AND
	 identificador
token ID
token SEMI
	 identificador
	 operacion AND
	 write expresion
	 secuencia sentencias
token WRITE
token ID
token OR
	 identificador
token ID
token SEMI
	 identificador
	 operacion OR
	 write expresion
	 secuencia sentencias
token WRITE
token NOT
token ID
token SEMI
	 identificador
	 operacion NOT
	 write expresion
	 secuencia sentencias
token END
Syntax error
instead expected token classes are [error, IF, REPEAT, READ, WRITE, RETURN, CALL, VAR, FOR, BREAK, CONTINUE, ID]
	 error en sentencia
Error sintáctico en sentencia
	 secuencia sentencias
	 programa principal
	 regla programa solo main

IMPRESION DEL AST GENERADO

  Tipo de nodo desconocido
*** Tabla de Simbolos ***
Total de posiciones de memoria utilizadas: 4
Variable: a -> Direccion: 2
Variable: b -> Direccion: 3
Variable: x -> Direccion: 0
Variable: y -> Direccion: 1


------ CODIGO OBJETO DEL LENGUAJE TINY GENERADO PARA LA TM ------


* * Compilacion TINY para la maquina TM
* * Prefacio estandar
0:      LDC       5,0(0)        init: GP = 0
1:      LDC       6,1023(0)      init: MP = 1023 (tope de memoria)
* * Fin del prefacio estandar
* -> programa
* -> declaracion: x
* Declaracion de variable: x (local)
2:      LDC       0,0(0)        local: inicializar variable x a cero
3:      ST        0,0(5)        local: almacenar en direccion 0
* <- declaracion
* -> declaracion: y
* Declaracion de variable: y (local)
4:      LDC       0,0(0)        local: inicializar variable y a cero
5:      ST        0,1(5)        local: almacenar en direccion 1
* <- declaracion
* -> declaracion: a
* Declaracion de variable: a (local)
6:      LDC       0,0(0)        local: inicializar variable a a cero
7:      ST        0,2(5)        local: almacenar en direccion 2
* <- declaracion
* -> declaracion: b
* Declaracion de variable: b (local)
8:      LDC       0,0(0)        local: inicializar variable b a cero
9:      ST        0,3(5)        local: almacenar en direccion 3
* <- declaracion
* -> leer
10:     IN        0,0,0         leer: lee un valor entero 
11:     ST        0,0(5)        leer: almaceno el valor entero leido en el id x
* <- leer
* -> leer
12:     IN        0,0,0         leer: lee un valor entero 
13:     ST        0,1(5)        leer: almaceno el valor entero leido en el id y
* <- leer
* -> escribir
* -> Operacion: mayor
* -> identificador
14:     LD        0,0(5)        cargar id: val[x]
* <- identificador
15:     ST        0,0(6)        op: push en la pila tmp el resultado expresion izquierda
* -> identificador
16:     LD        0,1(5)        cargar id: val[y]
* <- identificador
17:     LD        1,0(6)        op: pop o cargo de la pila el valor izquierdo en AC1
18:     SUB       0,1,0         op: >
19:     JGT       0,2(7)        saltar si AC>0
20:     LDC       0,0(0)        caso falso
21:     LDA       7,1(7)        saltar caso verdadero
22:     LDC       0,1(0)        caso verdadero
* <- Operacion: mayor
23:     OUT       0,0,0         escribir: genero la salida de la expresion
* <- escribir
* -> escribir
* -> Operacion: mayorigual
* -> identificador
24:     LD        0,0(5)        cargar id: val[x]
* <- identificador
25:     ST        0,0(6)        op: push en la pila tmp el resultado expresion izquierda
* -> identificador
26:     LD        0,1(5)        cargar id: val[y]
* <- identificador
27:     LD        1,0(6)        op: pop o cargo de la pila el valor izquierdo en AC1
28:     SUB       0,1,0         op: >=
29:     JGE       0,2(7)        saltar si AC>=0
30:     LDC       0,0(0)        caso falso
31:     LDA       7,1(7)        saltar caso verdadero
32:     LDC       0,1(0)        caso verdadero
* <- Operacion: mayorigual
33:     OUT       0,0,0         escribir: genero la salida de la expresion
* <- escribir
* -> escribir
* -> Operacion: menorigual
* -> identificador
34:     LD        0,0(5)        cargar id: val[x]
* <- identificador
35:     ST        0,0(6)        op: push en la pila tmp el resultado expresion izquierda
* -> identificador
36:     LD        0,1(5)        cargar id: val[y]
* <- identificador
37:     LD        1,0(6)        op: pop o cargo de la pila el valor izquierdo en AC1
38:     SUB       0,1,0         op: <=
39:     JLE       0,2(7)        saltar si AC<=0
40:     LDC       0,0(0)        caso falso
41:     LDA       7,1(7)        saltar caso verdadero
42:     LDC       0,1(0)        caso verdadero
* <- Operacion: menorigual
43:     OUT       0,0,0         escribir: genero la salida de la expresion
* <- escribir
* -> escribir
* -> Operacion: diferente
* -> identificador
44:     LD        0,0(5)        cargar id: val[x]
* <- identificador
45:     ST        0,0(6)        op: push en la pila tmp el resultado expresion izquierda
* -> identificador
46:     LD        0,1(5)        cargar id: val[y]
* <- identificador
47:     LD        1,0(6)        op: pop o cargo de la pila el valor izquierdo en AC1
48:     SUB       0,1,0         op: !=
49:     JNE       0,2(7)        saltar si AC!=0
50:     LDC       0,0(0)        caso falso
51:     LDA       7,1(7)        saltar caso verdadero
52:     LDC       0,1(0)        caso verdadero
* <- Operacion: diferente
53:     OUT       0,0,0         escribir: genero la salida de la expresion
* <- escribir
* -> escribir
* -> Operacion: igual
* -> identificador
54:     LD        0,0(5)        cargar id: val[x]
* <- identificador
55:     ST        0,0(6)        op: push en la pila tmp el resultado expresion izquierda
* -> identificador
56:     LD        0,1(5)        cargar id: val[y]
* <- identificador
57:     LD        1,0(6)        op: pop o cargo de la pila el valor izquierdo en AC1
58:     SUB       0,1,0         op: ==
59:     JEQ       0,2(7)        voy dos instrucciones mas alla if verdadero (AC==0)
60:     LDC       0,0(0)        caso de falso (AC=0)
61:     LDA       7,1(7)        Salto incodicional a direccion: PC+1 (es falso evito colocarlo verdadero)
62:     LDC       0,1(0)        caso de verdadero (AC=1)
* <- Operacion: igual
63:     OUT       0,0,0         escribir: genero la salida de la expresion
* <- escribir
* -> escribir
* -> Operacion: mas
* -> identificador
64:     LD        0,0(5)        cargar id: val[x]
* <- identificador
65:     ST        0,0(6)        op: push en la pila tmp el resultado expresion izquierda
* -> identificador
66:     LD        0,1(5)        cargar id: val[y]
* <- identificador
67:     LD        1,0(6)        op: pop o cargo de la pila el valor izquierdo en AC1
68:     ADD       0,1,0         op: +
* <- Operacion: mas
69:     OUT       0,0,0         escribir: genero la salida de la expresion
* <- escribir
* -> escribir
* -> Operacion: menos
* -> identificador
70:     LD        0,0(5)        cargar id: val[x]
* <- identificador
71:     ST        0,0(6)        op: push en la pila tmp el resultado expresion izquierda
* -> identificador
72:     LD        0,1(5)        cargar id: val[y]
* <- identificador
73:     LD        1,0(6)        op: pop o cargo de la pila el valor izquierdo en AC1
74:     SUB       0,1,0         op: -
* <- Operacion: menos
75:     OUT       0,0,0         escribir: genero la salida de la expresion
* <- escribir
* -> escribir
* -> Operacion: por
* -> identificador
76:     LD        0,0(5)        cargar id: val[x]
* <- identificador
77:     ST        0,0(6)        op: push en la pila tmp el resultado expresion izquierda
* -> identificador
78:     LD        0,1(5)        cargar id: val[y]
* <- identificador
79:     LD        1,0(6)        op: pop o cargo de la pila el valor izquierdo en AC1
80:     MUL       0,1,0         op: *
* <- Operacion: por
81:     OUT       0,0,0         escribir: genero la salida de la expresion
* <- escribir
* -> if
* -> Operacion: diferente
* -> identificador
82:     LD        0,1(5)        cargar id: val[y]
* <- identificador
83:     ST        0,0(6)        op: push en la pila tmp el resultado expresion izquierda
* -> constante
84:     LDC       0,0(0)        cargar constante: 0
* <- constante
85:     LD        1,0(6)        op: pop o cargo de la pila el valor izquierdo en AC1
86:     SUB       0,1,0         op: !=
87:     JNE       0,2(7)        saltar si AC!=0
88:     LDC       0,0(0)        caso falso
89:     LDA       7,1(7)        saltar caso verdadero
90:     LDC       0,1(0)        caso verdadero
* <- Operacion: diferente
* If: el salto hacia el else debe estar aqui
* -> escribir
* -> Operacion: entre
* -> identificador
92:     LD        0,0(5)        cargar id: val[x]
* <- identificador
93:     ST        0,0(6)        op: push en la pila tmp el resultado expresion izquierda
* -> identificador
94:     LD        0,1(5)        cargar id: val[y]
* <- identificador
95:     LD        1,0(6)        op: pop o cargo de la pila el valor izquierdo en AC1
96:     DIV       0,1,0         op: /
* <- Operacion: entre
97:     OUT       0,0,0         escribir: genero la salida de la expresion
* <- escribir
* If: el salto hacia el final debe estar aqui
91:     JEQ       0,7(7)        if: jmp hacia else
* <- if
* -> escribir
* -> Operacion: modulo
* -> identificador
99:     LD        0,0(5)        cargar id: val[x]
* <- identificador
100:    ST        0,0(6)        op: push en la pila tmp el resultado expresion izquierda
* -> identificador
101:    LD        0,1(5)        cargar id: val[y]
* <- identificador
102:    LD        1,0(6)        op: pop o cargo de la pila el valor izquierdo en AC1
103:    ST        0,0(6)        mod: guardar b
104:    ST        1,-1(6)       mod: guardar a
105:    DIV       0,1,0         mod: a/b
106:    LD        1,-1(6)       mod: recuperar a
107:    LD        2,0(6)        mod: recuperar b en r2
108:    MUL       0,0,2         mod: (a/b)*b
109:    SUB       0,1,0         mod: a - (a/b)*b
* <- Operacion: modulo
110:    OUT       0,0,0         escribir: genero la salida de la expresion
* <- escribir
* -> escribir
* -> Operacion: potencia
* -> identificador
111:    LD        0,0(5)        cargar id: val[x]
* <- identificador
112:    ST        0,0(6)        op: push en la pila tmp el resultado expresion izquierda
* -> constante
113:    LDC       0,2(0)        cargar constante: 2
* <- constante
114:    LD        1,0(6)        op: pop o cargo de la pila el valor izquierdo en AC1
115:    ST        0,0(6)        pow: guardar exp
116:    ST        1,-1(6)       pow: guardar base
117:    LDC       0,1(0)        pow: inicializar resultado = 1
118:    ST        0,-2(6)       pow: guardar res
* pow: inicio bucle
119:    LD        0,0(6)        pow: cargar exp
* pow: salto condicional a fin (exp==0)
121:    LD        0,-2(6)       pow: cargar res
122:    LD        1,-1(6)       pow: cargar base
123:    MUL       0,1,0         pow: res = res * base
124:    ST        0,-2(6)       pow: guardar res
125:    LD        1,0(6)        pow: cargar exp en AC1
126:    LDC       0,1(0)        pow: cargar 1
127:    SUB       0,1,0         pow: exp - 1
128:    ST        0,0(6)        pow: guardar exp
129:    LDA       7,-11(7)      pow: repetir
120:    JEQ       0,9(7)        pow: salir si exp == 0
130:    LD        0,-2(6)       pow: cargar resultado
131:    LD        1,-2(6)       pow: pop res
132:    LD        1,-1(6)       pow: pop base
133:    LD        1,0(6)        pow: pop exp
* <- Operacion: potencia
134:    OUT       0,0,0         escribir: genero la salida de la expresion
* <- escribir
* -> asignacion
* -> Operacion: menorigual
* -> identificador
135:    LD        0,0(5)        cargar id: val[x]
* <- identificador
136:    ST        0,0(6)        op: push en la pila tmp el resultado expresion izquierda
* -> identificador
137:    LD        0,1(5)        cargar id: val[y]
* <- identificador
138:    LD        1,0(6)        op: pop o cargo de la pila el valor izquierdo en AC1
139:    SUB       0,1,0         op: <=
140:    JLE       0,2(7)        saltar si AC<=0
141:    LDC       0,0(0)        caso falso
142:    LDA       7,1(7)        saltar caso verdadero
143:    LDC       0,1(0)        caso verdadero
* <- Operacion: menorigual
144:    ST        0,2(5)        asignacion: almaceno el valor para el id a
* <- asignacion
* -> asignacion
* -> Operacion: mayorigual
* -> identificador
145:    LD        0,0(5)        cargar id: val[x]
* <- identificador
146:    ST        0,0(6)        op: push en la pila tmp el resultado expresion izquierda
* -> identificador
147:    LD        0,1(5)        cargar id: val[y]
* <- identificador
148:    LD        1,0(6)        op: pop o cargo de la pila el valor izquierdo en AC1
149:    SUB       0,1,0         op: >=
150:    JGE       0,2(7)        saltar si AC>=0
151:    LDC       0,0(0)        caso falso
152:    LDA       7,1(7)        saltar caso verdadero
153:    LDC       0,1(0)        caso verdadero
* <- Operacion: mayorigual
154:    ST        0,3(5)        asignacion: almaceno el valor para el id b
* <- asignacion
* -> escribir
* -> Operacion: and
* -> identificador
155:    LD        0,2(5)        cargar id: val[a]
* <- identificador
156:    ST        0,0(6)        op: push en la pila tmp el resultado expresion izquierda
* -> identificador
157:    LD        0,3(5)        cargar id: val[b]
* <- identificador
158:    LD        1,0(6)        op: pop o cargo de la pila el valor izquierdo en AC1
159:    JEQ       1,3(7)        and: si izquierdo es falso, resultado es falso
160:    JEQ       0,2(7)        and: si derecho es falso, resultado es falso
161:    LDC       0,1(0)        and: ambos verdaderos
162:    LDA       7,1(7)        and: saltar caso falso
163:    LDC       0,0(0)        and: resultado falso
* <- Operacion: and
164:    OUT       0,0,0         escribir: genero la salida de la expresion
* <- escribir
* -> escribir
* -> Operacion: or
* -> identificador
165:    LD        0,2(5)        cargar id: val[a]
* <- identificador
166:    ST        0,0(6)        op: push en la pila tmp el resultado expresion izquierda
* -> identificador
167:    LD        0,3(5)        cargar id: val[b]
* <- identificador
168:    LD        1,0(6)        op: pop o cargo de la pila el valor izquierdo en AC1
169:    JNE       1,3(7)        or: si izquierdo es verdadero, resultado es verdadero
170:    JNE       0,2(7)        or: si derecho es verdadero, resultado es verdadero
171:    LDC       0,0(0)        or: ambos falsos
172:    LDA       7,1(7)        or: saltar caso verdadero
173:    LDC       0,1(0)        or: resultado verdadero
* <- Operacion: or
174:    OUT       0,0,0         escribir: genero la salida de la expresion
* <- escribir
* -> escribir
* -> Operacion: not
* -> identificador
175:    LD        0,2(5)        cargar id: val[a]
* <- identificador
176:    JEQ       0,2(7)        not: saltar si es cero (falso)
177:    LDC       0,0(0)        not: resultado falso
178:    LDA       7,1(7)        not: saltar carga de verdadero
179:    LDC       0,1(0)        not: resultado verdadero
* <- Operacion: not
180:    OUT       0,0,0         escribir: genero la salida de la expresion
* <- escribir
* <- programa
* Fin de la ejecucion.
181:    HALT      0,0,0         


------ FIN DEL CODIGO OBJETO DEL LENGUAJE TINY GENERADO PARA LA TM ------

Generando archivo de código objeto: ejemplo_generado/ejemplo_operadores.tm
Generando código objeto en archivo: ejemplo_generado/ejemplo_operadores.tm
Archivo ejemplo_generado/ejemplo_operadores.tm generado exitosamente.
