token COMENTARIO
token COMENTARIO_LINEA
token GLOBAL
token ID
token SEMI
token GLOBAL
	 declaracion global variable
	 declaracion unica
token ID
token COLON
token ARRAY
token LBRACKET
token NUM
token RBRACKET
token SEMI
token COMENTARIO_LINEA
token FUNCTION
	 declaracion global array
	 secuencia declaraciones
token ID
token LPAREN
token ID
token COLON
token ARRAY
token LBRACKET
token RBRACKET
token COMMA
token ID
token RPAREN
	 lista parametros
token BEGIN
token VAR
token ID
token SEMI
token VAR
	 declaracion variable local
	 sentencia unica
token ID
token SEMI
token ID
	 declaracion variable local
	 secuencia sentencias sin punto y coma
token ASSIGN
token NUM
token SEMI
	 numero entero
	 asignacion variable
	 secuencia sentencias sin punto y coma
token FOR
token ID
token ASSIGN
token NUM
token TO
	 numero entero
token ID
token MINUS
	 identificador
token NUM
token STEP
	 numero entero
	 resta
token NUM
token ID
	 numero entero
token ASSIGN
token ID
token PLUS
	 identificador
token ID
token LBRACKET
token ID
token RBRACKET
	 identificador
token SEMI
	 acceso array
	 suma
	 asignacion variable
	 sentencia unica
token IF
token ID
token LBRACKET
token ID
token RBRACKET
	 identificador
token LT
	 acceso array
token NUM
token THEN
	 numero entero
	 operacion menor
token CONTINUE
token END
	 continue
	 sentencia unica
token SEMI
	 if simple
	 secuencia sentencias
token IF
token ID
token GT
	 identificador
token NUM
token THEN
	 numero entero
	 operacion mayor
token BREAK
token END
	 break
	 sentencia unica
token END
	 if simple
	 secuencia sentencias
token SEMI
	 for con step
	 secuencia sentencias
token RETURN
token ID
token END
	 identificador
	 return con valor
	 secuencia sentencias
token COMENTARIO_LINEA
token BEGIN
	 declaracion funcion con parametros
	 secuencia declaraciones
token VAR
token ID
token SEMI
token VAR
	 declaracion variable local
	 sentencia unica
token ID
token SEMI
token VAR
	 declaracion variable local
	 secuencia sentencias sin punto y coma
token ID
token SEMI
token COMENTARIO_LINEA
token READ
	 declaracion variable local
	 secuencia sentencias sin punto y coma
token ID
token SEMI
	 read variable
	 secuencia sentencias sin punto y coma
token COMENTARIO_LINEA
token FOR
token ID
token ASSIGN
token NUM
token TO
	 numero entero
token NUM
token STEP
	 numero entero
token NUM
token ID
	 numero entero
token LBRACKET
token ID
token RBRACKET
	 identificador
token ASSIGN
token ID
token TIMES
	 identificador
token NUM
token PLUS
	 numero entero
	 multiplicacion
token NUM
token END
	 numero entero
	 suma
	 asignacion array
	 sentencia unica
token SEMI
	 for con step
	 secuencia sentencias
token COMENTARIO_LINEA
token IF
token ID
token GE
	 identificador
token NUM
token AND
	 numero entero
	 operacion mayor igual
token ID
token LE
	 identificador
token NUM
token THEN
	 numero entero
	 operacion menor igual
	 operacion AND
token WRITE
token ID
token SEMI
	 identificador
	 write expresion
	 sentencia unica
token COMENTARIO_LINEA
token IF
token ID
token MOD
	 identificador
token NUM
token EQ
	 numero entero
	 modulo
token NUM
token THEN
	 numero entero
	 operacion igual
token WRITE
token NUM
token ELSE
	 numero entero
	 write expresion
	 sentencia unica
token WRITE
token NUM
token END
	 numero entero
	 write expresion
	 sentencia unica
token SEMI
	 if-else
	 secuencia sentencias
token COMENTARIO_LINEA
token ID
token ASSIGN
token ID
token POW
	 identificador
token NUM
token SEMI
	 numero entero
	 potencia
	 asignacion variable
	 secuencia sentencias
token WRITE
token ID
token ELSE
	 identificador
	 write expresion
	 secuencia sentencias
token WRITE
token NUM
token END
	 numero entero
	 write expresion
	 sentencia unica
token SEMI
	 if-else
	 secuencia sentencias
token COMENTARIO_LINEA
token ID
token ASSIGN
token CALL
token ID
token LPAREN
token ID
token COMMA
	 identificador
token NUM
token RPAREN
	 numero entero
	 lista argumentos
token SEMI
	 llamada funcion en expresion
	 asignacion variable
	 secuencia sentencias
token WRITE
token ID
token SEMI
	 identificador
	 write expresion
	 secuencia sentencias
token COMENTARIO_LINEA
token IF
token LPAREN
token ID
token GT
	 identificador
token NUM
token RPAREN
	 numero entero
	 operacion mayor
token OR
	 expresion parentesis
token LPAREN
token ID
token LT
	 identificador
token NUM
token RPAREN
	 numero entero
	 operacion menor
token THEN
	 expresion parentesis
	 operacion OR
token WRITE
token NUM
token END
	 numero entero
	 write expresion
	 sentencia unica
token SEMI
	 if simple
	 secuencia sentencias
token IF
token NOT
token LPAREN
token ID
token NE
	 identificador
token NUM
token RPAREN
	 numero entero
	 operacion diferente
token THEN
	 expresion parentesis
	 operacion NOT
token WRITE
token NUM
token END
	 numero entero
	 write expresion
	 sentencia unica
token END
	 if simple
	 secuencia sentencias
	 programa principal
	 regla programa completo

IMPRESION DEL AST GENERADO

  Tipo de nodo desconocido
Array arr ocupa 10 posiciones de memoria
*** Tabla de Simbolos ***
Total de posiciones de memoria utilizadas: 18
Variable: arr -> Direccion: 1
Variable: suma_vector -> Direccion: 11
Variable: total -> Direccion: 15
Variable: size -> Direccion: 13
Variable: resultado -> Direccion: 17
Variable: v -> Direccion: 12
Variable: num -> Direccion: 16
Variable: x -> Direccion: 0
Variable: i -> Direccion: 14


------ CODIGO OBJETO DEL LENGUAJE TINY GENERADO PARA LA TM ------


* * Compilacion TINY para la maquina TM
* * Prefacio estandar
0:      LDC       5,0(0)        init: GP = 0
1:      LDC       6,1023(0)      init: MP = 1023 (tope de memoria)
* * Fin del prefacio estandar
* -> programa
* -> declaracion: x
* Declaracion de variable: x (global)
2:      LDC       0,0(0)        global: inicializar variable x a cero
3:      ST        0,0(5)        global: almacenar en direccion 0
* <- declaracion
* -> declaracion: arr
* Declaracion de array: arr tamaño definido
* -> constante
4:      LDC       0,10(0)       cargar constante: 10
* <- constante
5:      LDC       0,0(0)        array: inicializar elemento 0 a cero
6:      ST        0,1(5)        array: almacenar en posicion 1
7:      LDC       0,0(0)        array: inicializar elemento 1 a cero
8:      ST        0,2(5)        array: almacenar en posicion 2
9:      LDC       0,0(0)        array: inicializar elemento 2 a cero
10:     ST        0,3(5)        array: almacenar en posicion 3
11:     LDC       0,0(0)        array: inicializar elemento 3 a cero
12:     ST        0,4(5)        array: almacenar en posicion 4
13:     LDC       0,0(0)        array: inicializar elemento 4 a cero
14:     ST        0,5(5)        array: almacenar en posicion 5
15:     LDC       0,0(0)        array: inicializar elemento 5 a cero
16:     ST        0,6(5)        array: almacenar en posicion 6
17:     LDC       0,0(0)        array: inicializar elemento 6 a cero
18:     ST        0,7(5)        array: almacenar en posicion 7
19:     LDC       0,0(0)        array: inicializar elemento 7 a cero
20:     ST        0,8(5)        array: almacenar en posicion 8
21:     LDC       0,0(0)        array: inicializar elemento 8 a cero
22:     ST        0,9(5)        array: almacenar en posicion 9
23:     LDC       0,0(0)        array: inicializar elemento 9 a cero
24:     ST        0,10(5)       array: almacenar en posicion 10
* <- declaracion
* registrada funcion: suma_vector
* -> declaracion: i
* Declaracion de variable: i (local)
25:     LDC       0,0(0)        local: inicializar variable i a cero
26:     ST        0,14(5)       local: almacenar en direccion 14
* <- declaracion
* -> declaracion: num
* Declaracion de variable: num (local)
27:     LDC       0,0(0)        local: inicializar variable num a cero
28:     ST        0,16(5)       local: almacenar en direccion 16
* <- declaracion
* -> declaracion: resultado
* Declaracion de variable: resultado (local)
29:     LDC       0,0(0)        local: inicializar variable resultado a cero
30:     ST        0,17(5)       local: almacenar en direccion 17
* <- declaracion
* -> leer
31:     IN        0,0,0         leer: lee un valor entero 
32:     ST        0,16(5)       leer: almaceno el valor entero leido en el id num
* <- leer
* -> for
* -> constante
33:     LDC       0,0(0)        cargar constante: 0
* <- constante
34:     ST        0,14(5)       for: inicializar variable i
* for: inicio del bucle
35:     LD        0,14(5)       for: cargar variable de control
36:     ST        0,0(6)        for: guardar variable en pila temp
* -> constante
37:     LDC       0,9(0)        cargar constante: 9
* <- constante
38:     LD        1,0(6)        for: cargar variable de pila temp
39:     SUB       0,1,0         for: variable - valor_final
* for: salto condicional al final
* -> asignacion
* -> Operacion: mas
* -> Operacion: por
* -> identificador
41:     LD        0,14(5)       cargar id: val[i]
* <- identificador
42:     ST        0,0(6)        op: push en la pila tmp el resultado expresion izquierda
* -> constante
43:     LDC       0,2(0)        cargar constante: 2
* <- constante
44:     LD        1,0(6)        op: pop o cargo de la pila el valor izquierdo en AC1
45:     MUL       0,1,0         op: *
* <- Operacion: por
46:     ST        0,0(6)        op: push en la pila tmp el resultado expresion izquierda
* -> constante
47:     LDC       0,1(0)        cargar constante: 1
* <- constante
48:     LD        1,0(6)        op: pop o cargo de la pila el valor izquierdo en AC1
49:     ADD       0,1,0         op: +
* <- Operacion: mas
50:     ST        0,0(6)        asignacion array: guardar valor
* -> identificador
51:     LD        0,14(5)       cargar id: val[i]
* <- identificador
52:     LDC       1,1(0)        asignacion array: cargar direccion base
53:     ADD       0,0,1         asignacion array: calcular direccion
54:     LD        1,0(6)        asignacion array: recuperar valor
55:     ST        1,0(0)        asignacion array: almacenar en posicion calculada
* <- asignacion
* for: punto de continue
56:     LD        0,14(5)       for: cargar variable para incremento
57:     ST        0,0(6)        for: guardar variable en pila temp
* -> constante
58:     LDC       0,1(0)        cargar constante: 1
* <- constante
59:     LD        1,0(6)        for: cargar variable de pila temp
60:     ADD       0,1,0         for: incrementar variable
61:     ST        0,14(5)       for: guardar variable incrementada
62:     LDA       7,-28(7)      for: salto al inicio
* for: fin del bucle
40:     JGT       0,22(7)       for: saltar si variable > final
* <- for
* -> if
* -> Operacion: and
* -> Operacion: mayorigual
* -> identificador
63:     LD        0,16(5)       cargar id: val[num]
* <- identificador
64:     ST        0,0(6)        op: push en la pila tmp el resultado expresion izquierda
* -> constante
65:     LDC       0,0(0)        cargar constante: 0
* <- constante
66:     LD        1,0(6)        op: pop o cargo de la pila el valor izquierdo en AC1
67:     SUB       0,1,0         op: >=
68:     JGE       0,2(7)        saltar si AC>=0
69:     LDC       0,0(0)        caso falso
70:     LDA       7,1(7)        saltar caso verdadero
71:     LDC       0,1(0)        caso verdadero
* <- Operacion: mayorigual
72:     ST        0,0(6)        op: push en la pila tmp el resultado expresion izquierda
* -> Operacion: menorigual
* -> identificador
73:     LD        0,16(5)       cargar id: val[num]
* <- identificador
74:     ST        0,-1(6)       op: push en la pila tmp el resultado expresion izquierda
* -> constante
75:     LDC       0,10(0)       cargar constante: 10
* <- constante
76:     LD        1,-1(6)       op: pop o cargo de la pila el valor izquierdo en AC1
77:     SUB       0,1,0         op: <=
78:     JLE       0,2(7)        saltar si AC<=0
79:     LDC       0,0(0)        caso falso
80:     LDA       7,1(7)        saltar caso verdadero
81:     LDC       0,1(0)        caso verdadero
* <- Operacion: menorigual
82:     LD        1,0(6)        op: pop o cargo de la pila el valor izquierdo en AC1
83:     JEQ       1,3(7)        and: si izquierdo es falso, resultado es falso
84:     JEQ       0,2(7)        and: si derecho es falso, resultado es falso
85:     LDC       0,1(0)        and: ambos verdaderos
86:     LDA       7,1(7)        and: saltar caso falso
87:     LDC       0,0(0)        and: resultado falso
* <- Operacion: and
* If: el salto hacia el else debe estar aqui
* -> escribir
* -> identificador
89:     LD        0,16(5)       cargar id: val[num]
* <- identificador
90:     OUT       0,0,0         escribir: genero la salida de la expresion
* <- escribir
* -> if
* -> Operacion: igual
* -> Operacion: modulo
* -> identificador
91:     LD        0,16(5)       cargar id: val[num]
* <- identificador
92:     ST        0,0(6)        op: push en la pila tmp el resultado expresion izquierda
* -> constante
93:     LDC       0,2(0)        cargar constante: 2
* <- constante
94:     LD        1,0(6)        op: pop o cargo de la pila el valor izquierdo en AC1
95:     ST        0,0(6)        mod: guardar b
96:     ST        1,-1(6)       mod: guardar a
97:     DIV       0,1,0         mod: a/b
98:     LD        1,-1(6)       mod: recuperar a
99:     LD        2,0(6)        mod: recuperar b en r2
100:    MUL       0,0,2         mod: (a/b)*b
101:    SUB       0,1,0         mod: a - (a/b)*b
* <- Operacion: modulo
102:    ST        0,0(6)        op: push en la pila tmp el resultado expresion izquierda
* -> constante
103:    LDC       0,0(0)        cargar constante: 0
* <- constante
104:    LD        1,0(6)        op: pop o cargo de la pila el valor izquierdo en AC1
105:    SUB       0,1,0         op: ==
106:    JEQ       0,2(7)        voy dos instrucciones mas alla if verdadero (AC==0)
107:    LDC       0,0(0)        caso de falso (AC=0)
108:    LDA       7,1(7)        Salto incodicional a direccion: PC+1 (es falso evito colocarlo verdadero)
109:    LDC       0,1(0)        caso de verdadero (AC=1)
* <- Operacion: igual
* If: el salto hacia el else debe estar aqui
* -> escribir
* -> constante
111:    LDC       0,1(0)        cargar constante: 1
* <- constante
112:    OUT       0,0,0         escribir: genero la salida de la expresion
* <- escribir
* If: el salto hacia el final debe estar aqui
110:    JEQ       0,3(7)        if: jmp hacia else
* -> escribir
* -> constante
114:    LDC       0,0(0)        cargar constante: 0
* <- constante
115:    OUT       0,0,0         escribir: genero la salida de la expresion
* <- escribir
113:    LDA       7,2(7)        if: jmp hacia el final
* <- if
* -> asignacion
* -> Operacion: potencia
* -> identificador
116:    LD        0,16(5)       cargar id: val[num]
* <- identificador
117:    ST        0,0(6)        op: push en la pila tmp el resultado expresion izquierda
* -> constante
118:    LDC       0,2(0)        cargar constante: 2
* <- constante
119:    LD        1,0(6)        op: pop o cargo de la pila el valor izquierdo en AC1
120:    ST        0,0(6)        pow: guardar exp
121:    ST        1,-1(6)       pow: guardar base
122:    LDC       0,1(0)        pow: inicializar resultado = 1
123:    ST        0,-2(6)       pow: guardar res
* pow: inicio bucle
124:    LD        0,0(6)        pow: cargar exp
* pow: salto condicional a fin (exp==0)
126:    LD        0,-2(6)       pow: cargar res
127:    LD        1,-1(6)       pow: cargar base
128:    MUL       0,1,0         pow: res = res * base
129:    ST        0,-2(6)       pow: guardar res
130:    LD        1,0(6)        pow: cargar exp en AC1
131:    LDC       0,1(0)        pow: cargar 1
132:    SUB       0,1,0         pow: exp - 1
133:    ST        0,0(6)        pow: guardar exp
134:    LDA       7,-11(7)      pow: repetir
125:    JEQ       0,9(7)        pow: salir si exp == 0
135:    LD        0,-2(6)       pow: cargar resultado
136:    LD        1,-2(6)       pow: pop res
137:    LD        1,-1(6)       pow: pop base
138:    LD        1,0(6)        pow: pop exp
* <- Operacion: potencia
139:    ST        0,0(5)        asignacion: almaceno el valor para el id x
* <- asignacion
* -> escribir
* -> identificador
140:    LD        0,0(5)        cargar id: val[x]
* <- identificador
141:    OUT       0,0,0         escribir: genero la salida de la expresion
* <- escribir
* If: el salto hacia el final debe estar aqui
88:     JEQ       0,54(7)       if: jmp hacia else
* -> escribir
* -> constante
143:    LDC       0,999(0)      cargar constante: 999
* <- constante
144:    OUT       0,0,0         escribir: genero la salida de la expresion
* <- escribir
142:    LDA       7,2(7)        if: jmp hacia el final
* <- if
* -> asignacion
* -> llamada funcion: suma_vector
* Procesando argumentos de la llamada
145:    LDC       0,1(0)        call: base addr de array arr
146:    ST        0,0(6)        call: guardar argumento
* -> constante
147:    LDC       0,10(0)       cargar constante: 10
* <- constante
148:    ST        0,-1(6)       call: guardar argumento
149:    LDA       0,3(7)        call: calcular return addr (PC+3)
150:    ST        0,-2(6)       call: push return addr
152:    LD        1,-2(6)       prologo: cargar RA de -(numArgs)(MP)
153:    ST        1,0(6)        prologo: colocar RA en 0(MP)
154:    LD        0,0(6)        prologo: cargar arg v
155:    ST        0,12(5)       prologo: guardar param v
156:    LD        0,-1(6)       prologo: cargar arg size
157:    ST        0,13(5)       prologo: guardar param size
* === INICIO FUNCION suma_vector ===
* -> declaracion: i
* Declaracion de variable: i (local)
158:    LDC       0,0(0)        local: inicializar variable i a cero
159:    ST        0,14(5)       local: almacenar en direccion 14
* <- declaracion
* -> declaracion: total
* Declaracion de variable: total (local)
160:    LDC       0,0(0)        local: inicializar variable total a cero
161:    ST        0,15(5)       local: almacenar en direccion 15
* <- declaracion
* -> asignacion
* -> constante
162:    LDC       0,0(0)        cargar constante: 0
* <- constante
163:    ST        0,15(5)       asignacion: almaceno el valor para el id total
* <- asignacion
* -> for
* -> constante
164:    LDC       0,0(0)        cargar constante: 0
* <- constante
165:    ST        0,14(5)       for: inicializar variable i
* for: inicio del bucle
166:    LD        0,14(5)       for: cargar variable de control
167:    ST        0,-3(6)       for: guardar variable en pila temp
* -> Operacion: menos
* -> identificador
168:    LD        0,13(5)       cargar id: val[size]
* <- identificador
169:    ST        0,-4(6)       op: push en la pila tmp el resultado expresion izquierda
* -> constante
170:    LDC       0,1(0)        cargar constante: 1
* <- constante
171:    LD        1,-4(6)       op: pop o cargo de la pila el valor izquierdo en AC1
172:    SUB       0,1,0         op: -
* <- Operacion: menos
173:    LD        1,-3(6)       for: cargar variable de pila temp
174:    SUB       0,1,0         for: variable - valor_final
* for: salto condicional al final
* -> asignacion
* -> Operacion: mas
* -> identificador
176:    LD        0,15(5)       cargar id: val[total]
* <- identificador
177:    ST        0,-3(6)       op: push en la pila tmp el resultado expresion izquierda
* -> identificador
* -> identificador
178:    LD        0,14(5)       cargar id: val[i]
* <- identificador
179:    LD        1,12(5)       identificador array param: cargar direccion base
180:    ADD       0,0,1         identificador array: calcular direccion
* <- identificador
181:    LD        1,-3(6)       op: pop o cargo de la pila el valor izquierdo en AC1
182:    ADD       0,1,0         op: +
* <- Operacion: mas
183:    ST        0,15(5)       asignacion: almaceno el valor para el id total
* <- asignacion
* -> if
* -> Operacion: menor
* -> identificador
* -> identificador
184:    LD        0,14(5)       cargar id: val[i]
* <- identificador
185:    LD        1,12(5)       identificador array param: cargar direccion base
186:    ADD       0,0,1         identificador array: calcular direccion
* <- identificador
187:    ST        0,-3(6)       op: push en la pila tmp el resultado expresion izquierda
* -> constante
188:    LDC       0,0(0)        cargar constante: 0
* <- constante
189:    LD        1,-3(6)       op: pop o cargo de la pila el valor izquierdo en AC1
190:    SUB       0,1,0         op: <
191:    JLT       0,2(7)        voy dos instrucciones mas alla if verdadero (AC<0)
192:    LDC       0,0(0)        caso de falso (AC=0)
193:    LDA       7,1(7)        Salto incodicional a direccion: PC+1 (es falso evito colocarlo verdadero)
194:    LDC       0,1(0)        caso de verdadero (AC=1)
* <- Operacion: menor
* If: el salto hacia el else debe estar aqui
* -> continue
* continue: salto al incremento del bucle
* <- continue
* If: el salto hacia el final debe estar aqui
195:    JEQ       0,1(7)        if: jmp hacia else
* <- if
* -> if
* -> Operacion: mayor
* -> identificador
197:    LD        0,15(5)       cargar id: val[total]
* <- identificador
198:    ST        0,-3(6)       op: push en la pila tmp el resultado expresion izquierda
* -> constante
199:    LDC       0,200(0)      cargar constante: 200
* <- constante
200:    LD        1,-3(6)       op: pop o cargo de la pila el valor izquierdo en AC1
201:    SUB       0,1,0         op: >
202:    JGT       0,2(7)        saltar si AC>0
203:    LDC       0,0(0)        caso falso
204:    LDA       7,1(7)        saltar caso verdadero
205:    LDC       0,1(0)        caso verdadero
* <- Operacion: mayor
* If: el salto hacia el else debe estar aqui
* -> break
* break: salto al final del bucle
* <- break
* If: el salto hacia el final debe estar aqui
206:    JEQ       0,1(7)        if: jmp hacia else
* <- if
* for: punto de continue
208:    LD        0,14(5)       for: cargar variable para incremento
209:    ST        0,-3(6)       for: guardar variable en pila temp
* -> constante
210:    LDC       0,1(0)        cargar constante: 1
* <- constante
211:    LD        1,-3(6)       for: cargar variable de pila temp
212:    ADD       0,1,0         for: incrementar variable
213:    ST        0,14(5)       for: guardar variable incrementada
214:    LDA       7,-49(7)      for: salto al inicio
* for: fin del bucle
175:    JGT       0,39(7)       for: saltar si variable > final
* <- for
* -> return
* -> identificador
215:    LD        0,15(5)       cargar id: val[total]
* <- identificador
216:    LD        1,0(6)        return: recuperar direccion de retorno
217:    LDA       7,0(1)        return: salto a direccion de retorno
* <- return
* Return implicito de funcion
218:    LD        1,0(6)        funcion: recuperar direccion de retorno
219:    LDA       7,0(1)        funcion: retorno
* === FIN FUNCION suma_vector ===
151:    LDA       7,0(7)        call: salto a funcion suma_vector
* <- llamada funcion
220:    ST        0,17(5)       asignacion: almaceno el valor para el id resultado
* <- asignacion
* -> escribir
* -> identificador
221:    LD        0,17(5)       cargar id: val[resultado]
* <- identificador
222:    OUT       0,0,0         escribir: genero la salida de la expresion
* <- escribir
* -> if
* -> Operacion: or
* -> Operacion: mayor
* -> identificador
223:    LD        0,16(5)       cargar id: val[num]
* <- identificador
224:    ST        0,-1(6)       op: push en la pila tmp el resultado expresion izquierda
* -> constante
225:    LDC       0,5(0)        cargar constante: 5
* <- constante
226:    LD        1,-1(6)       op: pop o cargo de la pila el valor izquierdo en AC1
227:    SUB       0,1,0         op: >
228:    JGT       0,2(7)        saltar si AC>0
229:    LDC       0,0(0)        caso falso
230:    LDA       7,1(7)        saltar caso verdadero
231:    LDC       0,1(0)        caso verdadero
* <- Operacion: mayor
232:    ST        0,-1(6)       op: push en la pila tmp el resultado expresion izquierda
* -> Operacion: menor
* -> identificador
233:    LD        0,16(5)       cargar id: val[num]
* <- identificador
234:    ST        0,-2(6)       op: push en la pila tmp el resultado expresion izquierda
* -> constante
235:    LDC       0,0(0)        cargar constante: 0
* <- constante
236:    LD        1,-2(6)       op: pop o cargo de la pila el valor izquierdo en AC1
237:    SUB       0,1,0         op: <
238:    JLT       0,2(7)        voy dos instrucciones mas alla if verdadero (AC<0)
239:    LDC       0,0(0)        caso de falso (AC=0)
240:    LDA       7,1(7)        Salto incodicional a direccion: PC+1 (es falso evito colocarlo verdadero)
241:    LDC       0,1(0)        caso de verdadero (AC=1)
* <- Operacion: menor
242:    LD        1,-1(6)       op: pop o cargo de la pila el valor izquierdo en AC1
243:    JNE       1,3(7)        or: si izquierdo es verdadero, resultado es verdadero
244:    JNE       0,2(7)        or: si derecho es verdadero, resultado es verdadero
245:    LDC       0,0(0)        or: ambos falsos
246:    LDA       7,1(7)        or: saltar caso verdadero
247:    LDC       0,1(0)        or: resultado verdadero
* <- Operacion: or
* If: el salto hacia el else debe estar aqui
* -> escribir
* -> constante
249:    LDC       0,1(0)        cargar constante: 1
* <- constante
250:    OUT       0,0,0         escribir: genero la salida de la expresion
* <- escribir
* If: el salto hacia el final debe estar aqui
248:    JEQ       0,3(7)        if: jmp hacia else
* <- if
* -> if
* -> Operacion: not
* -> Operacion: diferente
* -> identificador
252:    LD        0,16(5)       cargar id: val[num]
* <- identificador
253:    ST        0,-1(6)       op: push en la pila tmp el resultado expresion izquierda
* -> constante
254:    LDC       0,5(0)        cargar constante: 5
* <- constante
255:    LD        1,-1(6)       op: pop o cargo de la pila el valor izquierdo en AC1
256:    SUB       0,1,0         op: !=
257:    JNE       0,2(7)        saltar si AC!=0
258:    LDC       0,0(0)        caso falso
259:    LDA       7,1(7)        saltar caso verdadero
260:    LDC       0,1(0)        caso verdadero
* <- Operacion: diferente
261:    JEQ       0,2(7)        not: saltar si es cero (falso)
262:    LDC       0,0(0)        not: resultado falso
263:    LDA       7,1(7)        not: saltar carga de verdadero
264:    LDC       0,1(0)        not: resultado verdadero
* <- Operacion: not
* If: el salto hacia el else debe estar aqui
* -> escribir
* -> constante
266:    LDC       0,5(0)        cargar constante: 5
* <- constante
267:    OUT       0,0,0         escribir: genero la salida de la expresion
* <- escribir
* If: el salto hacia el final debe estar aqui
265:    JEQ       0,3(7)        if: jmp hacia else
* <- if
* <- programa
* Fin de la ejecucion.
269:    HALT      0,0,0         


------ FIN DEL CODIGO OBJETO DEL LENGUAJE TINY GENERADO PARA LA TM ------
Generando código objeto en archivo: ejemplo_generado/programa_extendido.tm
Archivo ejemplo_generado/programa_extendido.tm generado exitosamente.
