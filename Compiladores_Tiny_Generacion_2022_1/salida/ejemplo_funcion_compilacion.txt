token COMENTARIO
token GLOBAL
token ID
token SEMI
token BEGIN
	 declaracion global variable
	 declaracion unica
token VAR
token ID
token SEMI
token ID
	 declaracion variable local
	 sentencia unica
token ASSIGN
token NUM
token SEMI
	 numero entero
	 asignacion variable
	 secuencia sentencias sin punto y coma
token ID
token ASSIGN
token CALL
token ID
token LPAREN
token ID
token RPAREN
	 identificador
token SEMI
	 llamada funcion en expresion
	 asignacion variable
	 secuencia sentencias
token WRITE
token ID
token SEMI
	 identificador
	 write expresion
	 secuencia sentencias
token END
Syntax error
instead expected token classes are [error, IF, REPEAT, READ, WRITE, RETURN, CALL, VAR, FOR, BREAK, CONTINUE, ID]
token FUNCTION
token ID
token LPAREN
token ID
token RPAREN
token BEGIN
token VAR
token ID
token SEMI
token ID
	 error en sentencia
Error sintáctico en sentencia
	 secuencia sentencias
	 declaracion variable local
	 secuencia sentencias sin punto y coma
token ASSIGN
token ID
token TIMES
	 identificador
token NUM
token SEMI
	 numero entero
	 multiplicacion
	 asignacion variable
	 secuencia sentencias sin punto y coma
token ID
token ASSIGN
token ID
token PLUS
	 identificador
token NUM
token SEMI
	 numero entero
	 suma
	 asignacion variable
	 secuencia sentencias
token COMENTARIO_LINEA
token RETURN
token ID
token END
	 identificador
	 return con valor
	 secuencia sentencias
	 programa principal
	 regla programa completo

IMPRESION DEL AST GENERADO

  Tipo de nodo desconocido
*** Tabla de Simbolos ***
Total de posiciones de memoria utilizadas: 4
Variable: temp -> Direccion: 2
Variable: resultado -> Direccion: 1
Variable: num -> Direccion: 3
Variable: x -> Direccion: 0


------ CODIGO OBJETO DEL LENGUAJE TINY GENERADO PARA LA TM ------


* * Compilacion TINY para la maquina TM
* * Prefacio estandar
0:      LDC       5,0(0)        init: GP = 0
1:      LDC       6,1023(0)      init: MP = 1023 (tope de memoria)
* * Fin del prefacio estandar
* -> programa
* -> declaracion: x
* Declaracion de variable: x (global)
2:      LDC       0,0(0)        global: inicializar variable x a cero
3:      ST        0,0(5)        global: almacenar en direccion 0
* <- declaracion
* -> declaracion: resultado
* Declaracion de variable: resultado (local)
4:      LDC       0,0(0)        local: inicializar variable resultado a cero
5:      ST        0,1(5)        local: almacenar en direccion 1
* <- declaracion
* -> asignacion
* -> constante
6:      LDC       0,5(0)        cargar constante: 5
* <- constante
7:      ST        0,0(5)        asignacion: almaceno el valor para el id x
* <- asignacion
* -> asignacion
* -> llamada funcion: duplicar
* Procesando argumentos de la llamada
* -> identificador
8:      LD        0,0(5)        cargar id: val[x]
* <- identificador
9:      ST        0,0(6)        call: guardar argumento
10:     LDA       0,3(7)        call: calcular return addr (PC+3)
11:     ST        0,-1(6)       call: push return addr
* ERROR: llamada a funcion no definida: duplicar
12:     LDA       7,0(7)        call: salto a funcion duplicar
* <- llamada funcion
13:     ST        0,1(5)        asignacion: almaceno el valor para el id resultado
* <- asignacion
* -> escribir
* -> identificador
14:     LD        0,1(5)        cargar id: val[resultado]
* <- identificador
15:     OUT       0,0,0         escribir: genero la salida de la expresion
* <- escribir
* -> declaracion: temp
* Declaracion de variable: temp (local)
16:     LDC       0,0(0)        local: inicializar variable temp a cero
17:     ST        0,2(5)        local: almacenar en direccion 2
* <- declaracion
* -> asignacion
* -> Operacion: por
* -> identificador
18:     LD        0,3(5)        cargar id: val[num]
* <- identificador
19:     ST        0,-1(6)       op: push en la pila tmp el resultado expresion izquierda
* -> constante
20:     LDC       0,2(0)        cargar constante: 2
* <- constante
21:     LD        1,-1(6)       op: pop o cargo de la pila el valor izquierdo en AC1
22:     MUL       0,1,0         op: *
* <- Operacion: por
23:     ST        0,2(5)        asignacion: almaceno el valor para el id temp
* <- asignacion
* -> asignacion
* -> Operacion: mas
* -> identificador
24:     LD        0,0(5)        cargar id: val[x]
* <- identificador
25:     ST        0,-1(6)       op: push en la pila tmp el resultado expresion izquierda
* -> constante
26:     LDC       0,1(0)        cargar constante: 1
* <- constante
27:     LD        1,-1(6)       op: pop o cargo de la pila el valor izquierdo en AC1
28:     ADD       0,1,0         op: +
* <- Operacion: mas
29:     ST        0,0(5)        asignacion: almaceno el valor para el id x
* <- asignacion
* -> return
* -> identificador
30:     LD        0,2(5)        cargar id: val[temp]
* <- identificador
31:     LD        1,0(6)        return: recuperar direccion de retorno
32:     LDA       7,0(1)        return: salto a direccion de retorno
* <- return
* <- programa
* Fin de la ejecucion.
33:     HALT      0,0,0         


------ FIN DEL CODIGO OBJETO DEL LENGUAJE TINY GENERADO PARA LA TM ------

Generando archivo de código objeto: ejemplo_generado/ejemplo_funcion.tm
Generando código objeto en archivo: ejemplo_generado/ejemplo_funcion.tm
Archivo ejemplo_generado/ejemplo_funcion.tm generado exitosamente.
